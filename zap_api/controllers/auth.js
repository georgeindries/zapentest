const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const asyncHandler = require('../middleware/async');
const ErrorResponse = require('../utils/error-response');
const { getUserByEmail, registerUser } = require('../services/auth');

const getSignedJwtToken = (email) => jwt.sign(
  { id: email },
  process.env.JWT_SECRET,
  { expiresIn: process.env.JWT_EXPIRE },
);

// enteredPassword === actualPassword;
// Match user entered password to hashed password in database
const matchPassword = async (enteredPassword, actualPassword) => bcrypt.compare(
  enteredPassword,
  actualPassword,
);
// return await bcrypt.compare(enteredPassword, this.password);

// Get token from model, create cookie and send response
const sendTokenResponse = (user, statusCode, res) => {
  // Create token
  const token = getSignedJwtToken(user.email);

  res.status(statusCode).json({
    success: true,
    token,
  });
};

// @desc     Login user
// @route    POST /auth/login
// @access   Public
exports.login = asyncHandler(async (req, res, next) => {
  const { email, password } = req.body;

  // Validate email and password
  if (!email || !password) {
    return next(new ErrorResponse('Please provide an email and password', 400));
  }

  // Check for user
  let user;
  await getUserByEmail(email)
    .then((userObj) => {
      user = userObj;
    })
    .catch((err) => console.log(err));

  if (!user) {
    return next(new ErrorResponse('Invalid credentials', 401));
  }

  // Check if password matches
  let isMatch;
  await matchPassword(password, user.password).then((resComp) => {
    isMatch = resComp;
  });

  if (!isMatch) {
    return next(new ErrorResponse('Invalid credentials', 401));
  }

  sendTokenResponse(user, 200, res);
});

// @desc     Get authentication token
// @route    GET /auth/token
// @access   Public
exports.generateToken = asyncHandler(async (req, res, next) => {
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  sendTokenResponse({ userEmail }, 200, res);
});

// @desc     Logout user
// @route    GET /auth/logout
// @access   Private
exports.logout = asyncHandler(async (req, res, next) => {
  const [prefix, token] = req.headers.authorization.split(' ');
  res.status(200).json({
    success: true,
    data: {},
  });
});

// @desc     Register user
// @route    POST /auth/register
// @access   Public
exports.register = asyncHandler(async (req, res, next) => {
  const { email, password, name } = req.body;

  let errorMessage = '';
  const errorCode = 500;

  // Check for user
  let user;
  await getUserByEmail(email)
    .then((userObj) => {
      user = userObj;
    })
    .catch((err) => console.log(err));

  if (user) {
    return next(new ErrorResponse('This email is already assigned to a user!', 409));
  }

  await registerUser(email, password, name)
    .catch((errObj) => {
      errorMessage += errObj;
      console.log(errorMessage);
    });

  if (errorMessage !== '') {
    return next(
      new ErrorResponse(
        'Internal Server Error',
        errorCode,
      ),
    );
  }

  res.status(200).json({ success: true });
});
