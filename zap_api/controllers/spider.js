const jwt = require('jsonwebtoken');
const asyncHandler = require('../middleware/async');
const ErrorResponse = require('../utils/error-response');
const {
  storeSpiderRequest,
  getUserSpiderRequestsByPageAndLimit,
  getUserSpiderRequestsSize,
  getSpiderResultsSize,
  getUserSpiderResultsByPageAndLimit,
  getUserSpiderResultsSize,
} = require('../services/spider/spidering');
const { extractContextFromUrl } = require('../utils/utils');

// @desc POST request for spidering the application having the specified URL
// @route POST /spider
// @access private
exports.spider = asyncHandler(async (req, res, next) => {
  const {
    url,
    maxChildren,
    recurse,
    subtreeOnly,
  } = req.body;
  let errorMessage = '';
  const errorCode = 500;

  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  const status = 'NEW';
  const context = extractContextFromUrl(url);

  await storeSpiderRequest(
    context,
    url,
    maxChildren,
    recurse,
    subtreeOnly,
    new Date().getTime(),
    userEmail,
    status,
  )
    .then((resObj) => resObj)
    .catch((errObj) => {
      errorMessage += errObj.error;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
  });
});

// @desc Get request for spiders by page and limit
// @route GET spider/requests
// @access private
exports.getUserSpiderRequestsByPageAndLimit = asyncHandler(async (req, res, next) => {
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  const query = { ...req.query };
  const { page, limit } = query;
  let errorMessage = '';
  const errorCode = 500;
  let spiders = [];
  let size;

  await getUserSpiderRequestsByPageAndLimit(page, limit, userEmail)
    .then((resObj) => {
      spiders = resObj;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  await getUserSpiderRequestsSize(userEmail)
    .then((resObj) => {
      console.log(resObj);
      size = resObj.count;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
    spiders,
    size,
  });
});

// @desc Get request for spider results by page and limit
// @route GET spider/:id/results
// @access private
exports.getUserSpiderResultsByPageAndLimit = asyncHandler(async (req, res, next) => {
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  const spiderRequestId = req.params.id;
  const query = { ...req.query };
  const { page, limit } = query;
  let errorMessage = '';
  const errorCode = 500;
  let spiders = [];
  let size;

  await getUserSpiderResultsByPageAndLimit(userEmail, page, limit, spiderRequestId)
    .then((resObj) => {
      spiders = resObj;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  await getUserSpiderResultsSize(userEmail, spiderRequestId)
    .then((resObj) => {
      console.log(resObj);
      size = resObj.count;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
    spiders,
    size,
  });
});
