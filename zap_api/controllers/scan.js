const jwt = require('jsonwebtoken');
const asyncHandler = require('../middleware/async');
const ErrorResponse = require('../utils/error-response');
const {
  storeScanRequest,
  getUserScanRequestsByPageAndLimit,
  getUserScanRequestsSize,
  getUserSites,
  getUserScanRequestsByPageLimitAndUrl,
  getUserScanRequestsByUrlSize,
  getUserScanAlertsByLimitAndOffset,
  getUserScanAlertsSize,
} = require('../services/scan/scanning');
const { extractContextFromUrl } = require('../utils/utils');

// @desc POST request for scanning the application having the URL specified in the given context
// @route POST /scan
// @access private
exports.activeScan = asyncHandler(async (req, res, next) => {
  const {
    url,
    maxChildren,
    recurse,
    subtreeOnly,
  } = req.body;
  let errorMessage = '';
  const errorCode = 500;

  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  const status = 'NEW';
  const context = extractContextFromUrl(url);

  await storeScanRequest(
    context,
    url,
    maxChildren,
    recurse,
    subtreeOnly,
    new Date().getTime(),
    userEmail,
    status,
  )
    .then((resObj) => resObj)
    .catch((errObj) => {
      errorMessage += errObj.error;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
  });
});

// @desc Get request for scans by page and limit
// @route GET scan/requests
// @access private
exports.getUserScanRequestsByPageAndLimit = asyncHandler(async (req, res, next) => {
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  const query = { ...req.query };
  const { page, limit, url } = query;
  let errorMessage = '';
  const errorCode = 500;
  let scanRequests = [];
  let size;

  if (!url || url === null) {
    await getUserScanRequestsByPageAndLimit(page, limit, userEmail)
      .then((resObj) => {
        scanRequests = resObj;
      })
      .catch((errObj) => {
        errorMessage += errObj;
      });

    await getUserScanRequestsSize(userEmail)
      .then((resObj) => {
        size = resObj.count;
      })
      .catch((errObj) => {
        errorMessage += errObj;
      });

    if (errorMessage !== undefined && errorMessage !== '') {
      return next(
        new ErrorResponse(
          errorMessage,
          errorCode,
        ),
      );
    }

    res.status(200).json({
      success: true,
      scanRequests,
      size,
    });
  } else {
    await getUserScanRequestsByPageLimitAndUrl(page, limit, url, userEmail)
      .then((resObj) => {
        scanRequests = resObj;
      })
      .catch((errObj) => {
        errorMessage += errObj;
      });

    await getUserScanRequestsByUrlSize(userEmail, url)
      .then((resObj) => {
        size = resObj.count;
      })
      .catch((errObj) => {
        errorMessage += errObj;
      });

    if (errorMessage !== undefined && errorMessage !== '') {
      return next(
        new ErrorResponse(
          errorMessage,
          errorCode,
        ),
      );
    }

    res.status(200).json({
      success: true,
      scanRequests,
      size,
    });
  }
});

// @desc Get request for user scan alerts by page and limit
// @route GET scan/:id/alerts
// @access private
exports.getUserScanAlertsByLimitAndOffset = asyncHandler(async (req, res, next) => {
  const scanRequestId = req.params.id;
  const query = { ...req.query };
  const { page, limit } = query;
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  let errorMessage = '';
  const errorCode = 500;
  let alerts = [];
  let size;

  await getUserScanAlertsByLimitAndOffset(userEmail, page, limit, scanRequestId)
    .then((resObj) => {
      alerts = resObj;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  await getUserScanAlertsSize(userEmail, scanRequestId)
    .then((resObj) => {
      size = resObj.count;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
    alerts,
    size,
  });
});

// @desc Get request for user urls sites
// @route GET scan/sites
// @access private
exports.getUserSites = asyncHandler(async (req, res, next) => {
  const [_, token] = req.headers.authorization.split(' ');
  const decodedToken = jwt.verify(token, process.env.JWT_SECRET);
  const userEmail = decodedToken.id;
  let errorMessage = '';
  const errorCode = 500;
  let sites = [];

  await getUserSites(userEmail)
    .then((resObj) => {
      sites = resObj;
    })
    .catch((errObj) => {
      errorMessage += errObj;
    });

  if (errorMessage !== undefined && errorMessage !== '') {
    return next(
      new ErrorResponse(
        errorMessage,
        errorCode,
      ),
    );
  }

  res.status(200).json({
    success: true,
    sites,
  });
});
