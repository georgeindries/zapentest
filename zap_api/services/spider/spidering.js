const {
  saveSpiderRequest,
  getUserSpiderRequestsByLimitAndOffset,
  getUserSpiderRequestsCount,
  getUserSpiderResultsCount,
  getUserSpiderResultsByLimitAndOffset,
} = require('../../database/queries/spider');

exports.getUserSpiderRequestsByPageAndLimit = async (page, limit, userEmail) => {
  const offset = (page - 1) * limit;
  return getUserSpiderRequestsByLimitAndOffset(limit, offset, userEmail)
    .then((resObj) => {
      const spiderRequests = resObj.map((spiderRequest) => ({
        id: spiderRequest.id,
        url: spiderRequest.url,
        maxChildren: spiderRequest.max_children,
        recurse: spiderRequest.recurse,
        subtreeOnly: spiderRequest.subtree_only,
        date: spiderRequest.date,
        status: spiderRequest.status,
      }));
      return spiderRequests;
    })
    .catch((err) => {
      throw err;
    });
};

exports.getUserSpiderRequestsSize = async (userEmail) => getUserSpiderRequestsCount(userEmail)
  .then((resObj) => resObj)
  .catch((err) => {
    throw err;
  });

exports.getUserSpiderResultsByPageAndLimit = async (userEmail, page, limit, spiderRequestId) => {
  const offset = (page - 1) * limit;
  return getUserSpiderResultsByLimitAndOffset(userEmail, limit, offset, spiderRequestId)
    .then((resObj) => {
      const spiderResults = resObj.map((spiderResult) => ({
        url: spiderResult.url,
        processed: spiderResult.processed,
        statusReason: spiderResult.status_reason,
        method: spiderResult.method,
        reasonNotProcessed: spiderResult.reason_not_processed,
        statusCode: spiderResult.status_code,
      }));
      return spiderResults;
    })
    .catch((err) => {
      throw err;
    });
};

exports.getUserSpiderResultsSize = async (userEmail, spiderRequestId) => getUserSpiderResultsCount(
  userEmail,
  spiderRequestId,
)
  .then((resObj) => resObj)
  .catch((err) => {
    throw err;
  });

exports.storeSpiderRequest = (
  context,
  url,
  maxChildren,
  recurse,
  subtreeOnly,
  date,
  userEmail,
  status,
) => saveSpiderRequest(
  context,
  url,
  maxChildren,
  recurse,
  subtreeOnly,
  date,
  userEmail,
  status,
)
  .then((resObj) => resObj)
  .catch((err) => {
    throw err;
  });
