const { getPgClient } = require('../connect');

exports.saveScanRequest = async (
  context,
  url,
  maxChildren,
  recurse,
  subtreeOnly,
  date,
  userEmail,
  status,
) => {
  const client = getPgClient();
  const query = {
    name: 'save-scan-request',
    text: 'INSERT INTO scan_requests(context, url, max_children, recurse, subtree_only, date, user_email, status) VALUES ($1, $2, $3, $4, $5, to_timestamp($6 / 1000.0), $7, $8)',
    values: [context, url, maxChildren, recurse, subtreeOnly, date, userEmail, status],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.updateScanRequestStatus = async (id, status) => {
  const client = getPgClient();
  const query = {
    name: 'update-scan-request-status',
    text: 'UPDATE scan_requests SET status = $1 WHERE id = $2',
    values: [status, id],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanRequestsByLimitAndOffset = async (limit, offset, userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT id, context, url, max_children, recurse, subtree_only, date, user_email, status FROM scan_requests '
   + 'WHERE user_email = $1 '
   + 'ORDER BY date DESC '
   + 'LIMIT $2 OFFSET $3';
  const query = {
    name: 'fetch-scan-requests-by-limit-and-offset',
    text: queryText,
    values: [userEmail, limit, offset],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanRequestsCount = async (userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT COUNT(*) FROM scan_requests '
   + 'WHERE user_email = $1';
  const query = {
    name: 'count-scan-requests',
    text: queryText,
    values: [userEmail],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => ({ count: res.rows[0].count }))
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanAlertsByLimitAndOffset = async (userEmail, limit, offset, scanRequestId) => {
  const client = getPgClient();
  const queryText = 'SELECT sa.url, sa.risk, sa.method, sa.description, sa.name, sa.solution, sa.alert FROM scan_alerts sa'
    + ' INNER JOIN scan_requests sr ON sa.scan_request_id=sr.id'
    + ' WHERE sa.scan_request_id=$1 AND sr.user_email=$2'
    + ' LIMIT $3 OFFSET $4';
  const query = {
    name: 'fetch-scan-alerts-by-limit-and-offset',
    text: queryText,
    values: [scanRequestId, userEmail, limit, offset],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanAlertsCount = async (userEmail, scanRequestId) => {
  const client = getPgClient();
  const queryText = 'SELECT COUNT(*) FROM scan_alerts sa'
  + ' INNER JOIN scan_requests sr ON sa.scan_request_id=sr.id'
  + ' WHERE scan_request_id=$1 AND sr.user_email=$2';
  const query = {
    name: 'count-scan-alerts',
    text: queryText,
    values: [scanRequestId, userEmail],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => ({ count: res.rows[0].count }))
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserSites = async (userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT url, COUNT(url) AS number_of_requests '
  + 'FROM scan_requests WHERE user_email=$1 GROUP BY url';
  const query = {
    name: 'fetch-user-sites',
    text: queryText,
    values: [userEmail],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanRequestsByLimitOffsetAndUrl = async (limit, offset, url, userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT id, context, url, max_children, recurse, subtree_only, date, user_email, status FROM scan_requests '
   + 'WHERE user_email = $1 AND url = $2'
   + 'ORDER BY date DESC '
   + 'LIMIT $3 OFFSET $4';
  const query = {
    name: 'fetch-scan-requests-by-limit-offset-and-url',
    text: queryText,
    values: [userEmail, url, limit, offset],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserScanRequestsByUrlCount = async (userEmail, url) => {
  const client = getPgClient();
  const queryText = 'SELECT COUNT(*) FROM scan_requests '
   + 'WHERE user_email = $1 AND url = $2';
  const query = {
    name: 'count-scan-requests-by-url',
    text: queryText,
    values: [userEmail, url],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => ({ count: res.rows[0].count }))
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};
