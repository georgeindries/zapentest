const { getPgClient } = require('../connect');

exports.saveSpiderRequest = async (
  context,
  url,
  maxChildren,
  recurse,
  subtreeOnly,
  date,
  userEmail,
  status,
) => {
  const client = getPgClient();
  const query = {
    name: 'save-spider_request',
    text: 'INSERT INTO spider_requests(context, url, max_children, recurse, subtree_only, date, user_email, status) VALUES ($1, $2, $3, $4, $5, to_timestamp($6 / 1000.0), $7, $8)',
    values: [context, url, maxChildren, recurse, subtreeOnly, date, userEmail, status],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.updateSpiderRequestStatus = async (id, status) => {
  const client = getPgClient();
  const query = {
    name: 'update-spider-request-status',
    text: 'UPDATE spider_requests SET status = $1 WHERE id = $2',
    values: [status, id],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserSpiderRequestsByLimitAndOffset = async (limit, offset, userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT id, context, url, max_children, recurse, subtree_only, date, user_email, status FROM spider_requests '
   + 'WHERE user_email = $1 '
   + 'ORDER BY date DESC '
   + 'LIMIT $2 OFFSET $3';
  const query = {
    name: 'fetch-user-spiders-by-limit-and-offset',
    text: queryText,
    values: [userEmail, limit, offset],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserSpiderRequestsCount = async (userEmail) => {
  const client = getPgClient();
  const queryText = 'SELECT COUNT(*) FROM spider_requests'
   + ' WHERE user_email = $1';
  const query = {
    name: 'count-user-spiders-requests',
    text: queryText,
    values: [userEmail],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => ({ count: res.rows[0].count }))
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserSpiderResultsByLimitAndOffset = async (
  userEmail,
  limit,
  offset,
  spiderRequestId,
) => {
  const client = getPgClient();
  const queryText = 'SELECT s_res.url, s_res.processed, s_res.status_reason, s_res.method, s_res.reason_not_processed, s_res.status_code'
  + ' FROM spider_results s_res'
  + ' INNER JOIN spider_requests s_req ON s_res.spider_request_id=s_req.id'
  + ' WHERE s_res.spider_request_id=$1 AND s_req.user_email=$2'
  + ' LIMIT $3 OFFSET $4';
  const query = {
    name: 'fetch-user-spider-results-by-limit-and-offset',
    text: queryText,
    values: [spiderRequestId, userEmail, limit, offset],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => res.rows)
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};

exports.getUserSpiderResultsCount = async (userEmail, spiderRequestId) => {
  const client = getPgClient();
  const queryText = 'SELECT COUNT(*)'
  + ' FROM spider_results s_res'
  + ' INNER JOIN spider_requests s_req ON s_res.spider_request_id=s_req.id'
  + ' WHERE s_res.spider_request_id=$1 AND s_req.user_email=$2';
  const query = {
    name: 'count-user-spider-results',
    text: queryText,
    values: [spiderRequestId, userEmail],
  };
  await client.connect();
  return client
    .query(query)
    .then((res) => ({ count: res.rows[0].count }))
    .catch((err) => {
      throw err;
    })
    .finally(async () => {
      await client.end();
    });
};
