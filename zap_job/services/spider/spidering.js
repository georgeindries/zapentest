const { getZapClient } = require('../client/zaproxy-client');
const { saveSpiderResult, getOldestSpiderRequestByStatus, updateSpiderRequestStatus } = require('../../database/queries/spider');
const { createNewSession } = require('../session/session');
const { createContext, includeUrlInContext } = require('../context/context');
const { sleep } = require('../../utils/utils');

const spiderScan = (url, contextName, maxChildren, recurse, subTreeOnly) => {
  const zaproxy = getZapClient();
  return zaproxy.spider.scan(url, maxChildren, recurse, contextName, subTreeOnly)
    .then((res) => res)
    .catch((err) => {
      throw err;
    });
};

const getSpiderStatusByZapId = (scanId) => {
  const zaproxy = getZapClient();
  return zaproxy.spider.status(scanId)
    .then((res) => res)
    .catch((err) => {
      throw err;
    });
};

const getSpiderResultsZap = (scanId) => {
  const zaproxy = getZapClient();
  return zaproxy.spider.fullResults(scanId)
    .then((res) => res)
    .catch((err) => {
      throw err;
    });
};

const storeSpiderResults = async (spiderResults, spiderRequestId) => {
  for (let idx = 0; idx < spiderResults.length; idx += 1) {
    const spiderResult = spiderResults[idx];
    await saveSpiderResult(
      spiderRequestId,
      spiderResult.url,
      spiderResult.processed,
      spiderResult.statusReason,
      spiderResult.method,
      spiderResult.reasonNotProcessed,
      spiderResult.statusCode,
    );
  }
};

exports.executeSpiderRequests = async () => {
  let spiderRequest = null;
  let success = true;

  const statusFailed = 'FAILED';
  const statusInProgress = 'IN_PROGRESS';
  await getOldestSpiderRequestByStatus(statusInProgress)
    .then((resObj) => {
      spiderRequest = resObj;
    })
    .catch((errObj) => {
      success = false;
      console.log(errObj);
    });

  if ((spiderRequest !== null && spiderRequest !== undefined) || !success) return;

  const statusNew = 'NEW';
  await getOldestSpiderRequestByStatus(statusNew)
    .then((resObj) => {
      spiderRequest = resObj;
    })
    .catch((errObj) => {
      success = false;
      console.log(errObj);
    });

  if (spiderRequest === null || spiderRequest === undefined || !success) return;

  const {
    id,
    context,
    url,
    maxChildren,
    recurse,
    subtreeOnly,
  } = spiderRequest;

  if (success) {
    await updateSpiderRequestStatus(id, statusInProgress)
      .catch((errObj) => {
        success = false;
        console.log(`Error at updateSpiderRequestStatus(): ${errObj}`);
      });
  }

  if (success === true) {
    await createNewSession(context)
      .catch((errObj) => {
        success = false;
        console.log(`Error at createNewSession(): ${errObj.error.message}`);
      });
  }

  if (success === true) {
    await createContext(context)
      .catch((errObj) => {
        success = false;
        console.log(`Error at createContext(): ${errObj.error.message}`);
      });
  }

  if (success === true) {
    await includeUrlInContext(context, url)
      .catch((errObj) => {
        success = false;
        console.log(`Error at includeUrlInContext(): ${errObj.error.message}`);
      });
  }

  let idZap;
  if (success === true) {
    await spiderScan(url, context, maxChildren, recurse, subtreeOnly)
      .then((resObj) => {
        idZap = resObj.scan;
      })
      .catch((errObj) => {
        success = false;
        console.log(`Error at spiderScan(): ${errObj.error.message}`);
      });
  }

  let spiderStatus = 0;
  if (success) {
    while (spiderStatus < 100 && success === true) {
      await getSpiderStatusByZapId(idZap)
        .then((resObj) => {
          spiderStatus = resObj.status;
        })
        .catch((errObj) => {
          success = false;
          console.log(`Error at getSpiderStatusByZapId(): ${errObj.error.message}`);
        });
      await sleep(3000);
    }
  }

  let spiderResults;
  if (success) {
    await getSpiderResultsZap(idZap)
      .then((res) => {
        spiderResults = res.fullResults[0].urlsInScope;
      })
      .catch((errObj) => {
        success = false;
        console.log(`Error at getSpiderResultsZap(): ${errObj.error.message}`);
      });
  }

  if (success) {
    await storeSpiderResults(spiderResults, id)
      .catch((errObj) => {
        success = false;
        console.log(`Error at storeSpiderResults(): ${errObj}`);
      });
  }

  const statusDone = 'DONE';
  if (success) {
    await updateSpiderRequestStatus(id, statusDone)
      .catch((errObj) => {
        console.log(`Error at updateSpiderRequestStatus(): ${errObj}`);
      });
  }

  if (!success) {
    await updateSpiderRequestStatus(id, statusFailed)
      .catch((errObj) => {
        console.log(`Error at updateSpiderRequestStatus(): ${errObj}`);
      });
  }
};
